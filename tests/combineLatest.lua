local Observable = require("reactivex.observable")
local Observer = require("reactivex.observer")
local Subscription = require("reactivex.subscription")
local Subject = require("reactivex.subjects.subject")

require('reactivex.operators.combineLatest')

describe('combineLatest', function()
  it('returns the observable it is called on if only the identity function is passed as an argument', function()
    local observable = Observable.fromRange(1, 5):combineLatest(function(x) return x end)
    expect(observable).to.produce(1, 2, 3, 4, 5)
  end)

  it('unsubscribes from the combined source observables', function()
    local observableA = Observable.create(function(observer)
      return nil
    end)

    local unsubscribeB = spy()
    local subscriptionB = Subscription.create(unsubscribeB)
    local observableB = Observable.create(function(observer)
      return subscriptionB
    end)

    local subscription = Observable.combineLatest(observableA, observableB):subscribe()
    subscription:unsubscribe()
    expect(#unsubscribeB).to.equal(1)
  end)

  it('calls the combinator function with all values produced from all input observables once they have all produced a value', function()
    local observableA = Observable.of('a')
    local observableB = Observable.of('b')
    local observableC = Observable.of('c')
    local combinator = spy()
    Observable.combineLatest(observableA, observableB, observableC, function(...) combinator(...) end):subscribe()
    expect(combinator).to.equal({{'a', 'b', 'c'}})
  end)

  it('emits the return value of the combinator as values', function()
    local observableA = Subject.create()
    local observableB = Subject.create()
    local onNext = spy()
    Observable.combineLatest(observableA, observableB, function(a, b) return a + b end):subscribe(Observer.create(onNext))
    expect(#onNext).to.equal(0)
    observableA:onNext(1)
    observableB:onNext(2)
    observableB:onNext(3)
    observableA:onNext(4)
    expect(onNext).to.equal({{3}, {4}, {7}})
  end)

  it('calls onCompleted once all sources complete', function()
    local observableA = Subject.create()
    local observableB = Subject.create()
    local complete = spy()
    Observable.combineLatest(observableA, observableB, function() end):subscribe(nil, nil, complete)

    expect(#complete).to.equal(0)
    observableA:onNext(1)
    expect(#complete).to.equal(0)
    observableB:onNext(2)
    expect(#complete).to.equal(0)
    observableB:onCompleted()
    expect(#complete).to.equal(0)
    observableA:onCompleted()
    expect(#complete).to.equal(1)
  end)

  it('calls onError if one source errors', function()
    local observableA = Subject.create()
    local observableB = Subject.create()
    local errored = spy()
    Observable.combineLatest(observableA, observableB, function() end):subscribe(nil, errored)
    expect(#errored).to.equal(0)
    observableB:onError()
    expect(#errored).to.equal(1)
  end)

  it('calls onError if the combinator errors', function()
    expect(Observable.combineLatest(Observable.fromRange(3), error)).to.produce.error()
  end)
end)
