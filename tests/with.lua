local Observable = require("reactivex.observable")
local Observer = require("reactivex.observer")
local Subscription = require("reactivex.subscription")
local Subject = require("reactivex.subjects.subject")

require('reactivex.operators.with')

describe('with', function()
  it('returns the observable it is called on if no other sources are specified', function()
    local observable = Observable.fromRange(1, 5):with()
    expect(observable).to.produce(1, 2, 3, 4, 5)
  end)

  it('should produce the most recent values when the first observable produces a value', function()
    local subjectA = Subject.create()
    local subjectB = Subject.create()
    local onNext = spy()
    subjectA:with(subjectB):subscribe(Observer.create(onNext))
    subjectA:onNext('a')
    subjectA:onNext('b')
    subjectB:onNext('c')
    subjectB:onNext('d')
    subjectA:onNext('e')
    subjectA:onNext('f')
    expect(onNext).to.equal({{'a', nil}, {'b', nil}, {'e', 'd'}, {'f', 'd'}})
  end)

  it('should complete only when the first observable completes', function()
    local subjectA = Subject.create()
    local subjectB = Subject.create()
    local onCompleted = spy()
    subjectA:with(subjectB):subscribe(Observer.create(_, _, onCompleted))
    subjectA:onNext('a')
    subjectB:onNext('b')
    subjectB:onCompleted()
    expect(#onCompleted).to.equal(0)
    subjectA:onNext('c')
    subjectA:onNext('d')
    subjectA:onCompleted()
    expect(#onCompleted).to.equal(1)
  end)

  it('should unsubscribe from all source observables', function()
    local unsubscribeA = spy()
    local observableA = Observable.create(function(observer)
      return Subscription.create(unsubscribeA)
    end)

    local unsubscribeB = spy()
    local observableB = Observable.create(function(observer)
      return Subscription.create(unsubscribeB)
    end)

    local subscription = observableA:with(observableB):subscribe()
    subscription:unsubscribe()
    expect(#unsubscribeA).to.equal(1)
    expect(#unsubscribeB).to.equal(1)
  end)
end)
